@using Services
@using System.Security.Claims
@inject TimeCardService TimeCardService
@inject AuthenticationStateProvider AuthStateProvider

<div class="d-flex justify-content-center my-4">
    <div class="card shadow-sm clock-card">
        <div class="card-header bg-primary text-white">
            <div class="d-flex justify-content-between align-items-center">
                <h5 class="mb-0">Clock in/out</h5>
                <span class="badge rounded-pill @(isClockedIn ? "bg-success" : "bg-secondary")">@(isClockedIn ? "Clocked In" : "Clocked Out")</span>
            </div>
        </div>

        <div class="card-body">
            <div class="text-center mb-3">
                <h2 class="display-6 fw-bold">@currentTime.ToString("h:mm:ss tt")</h2>
                <small class="text-muted">Local time</small>
            </div>

            <div class="d-flex gap-2 justify-content-center mb-3">
                <button class="btn btn-success btn-lg" @onclick="ClockIn" disabled="@(isClockedIn || isGettingLocation)" aria-label="Clock In">
                    @if (isGettingLocation)
                    {
                        <span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>
                    }
                    else
                    {
                        <span>Clock In</span>
                    }
                </button>

                <button class="btn btn-outline-secondary btn-lg" @onclick="ClockOut" disabled="@(!isClockedIn)" aria-label="Clock Out">
                    Clock Out
                </button>
            </div>

            <div class="row">
                <div class="col-md-6 mb-2">
                    <div class="border rounded p-2">
                        <div class="d-flex justify-content-between">
                            <strong>Last Clock In</strong>
                            @if (clockInTime != default)
                            {
                                <span class="badge bg-success">@clockInTime.ToString("g")</span>
                            }
                        </div>
                        <div class="mt-2 small text-muted">
                            @if (latitude.HasValue && longitude.HasValue)
                            {
                                <div>Lat: @latitude.Value.ToString("0.000000")</div>
                                <div>Lng: @longitude.Value.ToString("0.000000")</div>
                                if (@accuracy != null){
                                    <div>Accuracy: @accuracy m</div>
                                } else {
                                    <div>Accuracy: 0 m</div>
                                }
                                <div class="mt-1">
                                    <a class="btn btn-sm btn-outline-primary" target="_blank" rel="noopener noreferrer"
                                       href=@GetMapsUrl(latitude.Value, longitude.Value)>Open in Maps</a>
                                </div>
                            }
                            else if (!string.IsNullOrEmpty(locationError))
                            {
                                <div class="text-danger">@locationError</div>
                            }
                            else
                            {
                                <div>No location captured yet.</div>
                            }
                        </div>
                    </div>
                </div>

                <div class="col-md-6 mb-2">
                    <div class="border rounded p-2">
                        <div class="d-flex justify-content-between">
                            <strong>Last Clock Out</strong>
                            @if (clockOutTime != default)
                            {
                                <span class="badge bg-secondary">@clockOutTime.ToString("g")</span>
                            }
                        </div>
                        <div class="mt-2 small text-muted">
                            <div>Clock in time: <strong>@(clockInTime == default ? "-" : clockInTime.ToString("HH:mm:ss"))</strong></div>
                            <div>Clock out time: <strong>@(clockOutTime == default ? "-" : clockOutTime.ToString("HH:mm:ss"))</strong></div>
                            <div>
                                Total duration: 
                                <strong>
                                    @(clockInTime != default && clockOutTime != default 
                                        ? (clockOutTime - clockInTime).ToString(@"hh\:mm\:ss") 
                                        : "-")
                                </strong>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

        </div>

        <div class="card-footer text-muted small text-end">
            Location access required. Permission prompt appears when you clock in.
        </div>
    </div>
</div>

<style>
    .clock-card { width: 100%; max-width: 820px; }
    @@media (max-width: 576px) {
        .clock-card { margin: 0 12px; }
    }
</style>

@inject IJSRuntime JS

@code {
    private DateTime currentTime;
    private double? latitude;
    private double? longitude;
    private double? accuracy;
    private string? locationError;
    private DateTime clockInTime;
    private DateTime clockOutTime;
    private bool isGettingLocation = false;
    private bool isClockedIn = false;
    private int timeEntryId;

    protected override async Task OnInitializedAsync()
    {
        // clock tick
        currentTime = DateTime.Now;
        var timer = new System.Timers.Timer(1000);
        timer.Elapsed += (sender, e) =>
        {
            currentTime = DateTime.Now;
            InvokeAsync(StateHasChanged);
        };
        timer.Start();

        // load last time entry for logged-in user using the requested method
        try
        {
            var authState = await AuthStateProvider.GetAuthenticationStateAsync();
            var user = authState.User;
            if (user.Identity?.IsAuthenticated ?? false)
            {
                var userId = user.FindFirst(ClaimTypes.NameIdentifier)?.Value;
                if (!string.IsNullOrEmpty(userId))
                {
                    // If your service method name differs, adjust accordingly.
                    var last = TimeCardService.GetLastTimeEntryForStudent(userId!); // <-- uses requested method

                    if (last != null)
                    {
                        // If there's an active entry (no TimeOut) mark clocked in and populate location/display
                        if (!last.TimeOut.HasValue)
                        {
                            isClockedIn = true;
                            timeEntryId = last.Id;
                            // ensure TimeIn is treated as UTC from DB and convert for display
                            clockInTime = DateTime.SpecifyKind(last.TimeIn, DateTimeKind.Utc).ToLocalTime();
                            latitude = last.Latitude;
                            longitude = last.Longitude;
                            accuracy = null; // accuracy not stored on clock in
                        }
                        else
                        {
                            // populate last clock out/display values
                            clockInTime = DateTime.SpecifyKind(last.TimeIn, DateTimeKind.Utc).ToLocalTime();
                            clockOutTime = DateTime.SpecifyKind(last.TimeOut.Value, DateTimeKind.Utc).ToLocalTime();
                            latitude = last.Latitude;
                            longitude = last.Longitude;
                            accuracy = null;
                        }
                    }
                }
            }
        }
        catch
        {
            // swallow init errors to avoid breaking the UI
        }
    }

    private async Task ClockIn()
    {
        clockInTime = DateTime.Now;
        var utcClockInTime = DateTime.UtcNow;
        locationError = null;
        isGettingLocation = true;
        try
        {
            var result = await JS.InvokeAsync<LocationResult>("geolocationInterop.getCurrentPosition");
            latitude = result.latitude;
            longitude = result.longitude;
            accuracy = result.accuracy;
        }
        catch (JSException jsEx)
        {
            locationError = jsEx.Message;
            return;
        }
        catch (Exception ex)
        {
            locationError = ex.Message;
            return;
        }
        finally
        {
            isGettingLocation = false;
        }
        await InvokeAsync(StateHasChanged);
        isClockedIn = true;

        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        if (!user.Identity?.IsAuthenticated ?? true)
        {
            locationError = "User is not authenticated.";
            return;
        }
        var userId = user.FindFirst(ClaimTypes.NameIdentifier)?.Value;

        timeEntryId = TimeCardService.CreateTimeEntry(userId!, utcClockInTime, latitude!.Value, longitude!.Value);
    }

    private Task ClockOut()
    {
        clockOutTime = DateTime.Now;
        StateHasChanged();
        isClockedIn = false;
        TimeCardService.CloseTimeEntry(timeEntryId, DateTime.UtcNow);

        return Task.CompletedTask;
    }

    private string GetMapsUrl(double lat, double lng) =>
        $"https://www.google.com/maps/search/?api=1&query={lat.ToString(System.Globalization.CultureInfo.InvariantCulture)},{lng.ToString(System.Globalization.CultureInfo.InvariantCulture)}";

    private class LocationResult
    {
        public double latitude { get; set; }
        public double longitude { get; set; }
        public double accuracy { get; set; }
    }
}

<script>
    window.geolocationInterop = {
        getCurrentPosition: function () {
            return new Promise(function (resolve, reject) {
                if (!navigator.geolocation) {
                    reject('Geolocation not supported by this browser.');
                    return;
                }
                navigator.geolocation.getCurrentPosition(function (pos) {
                    resolve({
                        latitude: pos.coords.latitude,
                        longitude: pos.coords.longitude,
                        accuracy: pos.coords.accuracy
                    });
                }, function (err) {
                    reject(err.message || 'Unable to get location');
                }, { enableHighAccuracy: true, timeout: 10000 });
            });
        }
    };
</script>